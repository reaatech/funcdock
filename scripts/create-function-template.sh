#!/bin/bash

# Create Function Template Script for FuncDock
# Usage: ./create-function-template.sh <function-name>

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper function for colored output
log() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Show usage if no arguments or help requested
if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    log $BLUE "üìÅ FuncDock Function Template Creator"
    echo ""
    log $YELLOW "Usage:"
    echo "  ./create-function-template.sh <function-name>"
    echo ""
    log $YELLOW "Examples:"
    echo "  ./create-function-template.sh my-api"
    echo "  ./create-function-template.sh user-service"
    echo "  ./create-function-template.sh data-processor"
    echo ""
    exit 1
fi

FUNCTION_NAME=$1
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
FUNCTIONS_DIR="$PROJECT_ROOT/functions"
FUNCTION_DIR="$FUNCTIONS_DIR/$FUNCTION_NAME"

# Validate function name
if [[ ! $FUNCTION_NAME =~ ^[a-z0-9-]+$ ]]; then
    log $RED "‚ùå Error: Function name must contain only lowercase letters, numbers, and hyphens"
    exit 1
fi

# Check if function already exists
if [ -d "$FUNCTION_DIR" ]; then
    log $RED "‚ùå Error: Function '$FUNCTION_NAME' already exists"
    exit 1
fi

log $BLUE "üìÅ Creating function template: $FUNCTION_NAME"

# Create function directory
mkdir -p "$FUNCTION_DIR"
log $GREEN "‚úÖ Created directory: functions/$FUNCTION_NAME"

# Create handler.js
cat > "$FUNCTION_DIR/handler.js" << EOF
/**
 * $FUNCTION_NAME Function
 * Generated by FuncDock template creator
 */

export default async function handler(req, res, next) {
  const { method, query, body, headers } = req;
  const { logger } = req; // Get the injected logger

  // Add CORS headers for browser requests
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  // Handle preflight requests
  if (method === 'OPTIONS') {
    return res.status(200).end();
  }

  // Log the request
  logger.info(\`Request received: \${method} \${req.routePath}\`, {
    query,
    hasBody: !!body,
    userAgent: headers['user-agent']
  });

  try {
    switch (method) {
      case 'GET':
        return await handleGet(req, res, next);

      case 'POST':
        return await handlePost(req, res, next);

      case 'PUT':
        return await handlePut(req, res, next);

      case 'DELETE':
        return await handleDelete(req, res, next);

      default:
        return res.status(405).json({
          error: 'Method Not Allowed',
          method,
          supportedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
          function: '$FUNCTION_NAME',
          timestamp: new Date().toISOString()
        });
    }
  } catch (error) {
    logger.error(\`Error in \${req.functionName}:\`, error);
    return res.status(500).json({
      error: 'Internal Server Error',
      message: error.message,
      function: '$FUNCTION_NAME',
      timestamp: new Date().toISOString()
    });
  }
}

async function handleGet(req, res, next) {
  const { id } = req.query;

  // Example GET implementation
  const response = {
    message: 'GET request successful',
    function: '$FUNCTION_NAME',
    timestamp: new Date().toISOString(),
    data: {
      id: id || 'no-id-provided',
      status: 'active',
      version: '1.0.0'
    }
  };

  return res.status(200).json(response);
}

async function handlePost(req, res, next) {
  const { body } = req;

  // Example POST implementation with validation
  if (!body || Object.keys(body).length === 0) {
    return res.status(400).json({
      error: 'Bad Request',
      message: 'Request body is required',
      function: '$FUNCTION_NAME',
      timestamp: new Date().toISOString()
    });
  }

  // Process the data here
  const response = {
    message: 'Resource created successfully',
    function: '$FUNCTION_NAME',
    timestamp: new Date().toISOString(),
    data: {
      id: \`\${Date.now()}-\${Math.random().toString(36).substr(2, 9)}\`,
      ...body,
      createdAt: new Date().toISOString()
    }
  };

  return res.status(201).json(response);
}

async function handlePut(req, res, next) {
  const { id } = req.query;
  const { body } = req;

  if (!id) {
    return res.status(400).json({
      error: 'Bad Request',
      message: 'ID parameter is required for updates',
      function: '$FUNCTION_NAME',
      timestamp: new Date().toISOString()
    });
  }

  // Example PUT implementation
  const response = {
    message: \`Resource \${id} updated successfully\`,
    function: '$FUNCTION_NAME',
    timestamp: new Date().toISOString(),
    data: {
      id,
      ...body,
      updatedAt: new Date().toISOString()
    }
  };

  return res.status(200).json(response);
}

async function handleDelete(req, res, next) {
  const { id } = req.query;

  if (!id) {
    return res.status(400).json({
      error: 'Bad Request',
      message: 'ID parameter is required for deletion',
      function: '$FUNCTION_NAME',
      timestamp: new Date().toISOString()
    });
  }

  // Example DELETE implementation
  const response = {
    message: \`Resource \${id} deleted successfully\`,
    function: '$FUNCTION_NAME',
    timestamp: new Date().toISOString(),
    data: {
      id,
      deletedAt: new Date().toISOString()
    }
  };

  return res.status(200).json(response);
}
EOF

log $GREEN "‚úÖ Created handler.js"

# Create package.json
cat > "$FUNCTION_DIR/package.json" << EOF
{
  "name": "$FUNCTION_NAME-function",
  "version": "1.0.0",
  "description": "$FUNCTION_NAME serverless function for FuncDock",
  "main": "handler.js",
  "type": "module",
  "scripts": {
    "test": "echo \\"Error: no test specified\\" && exit 1"
  },
  "dependencies": {

  },
  "devDependencies": {

  },
  "keywords": [
    "funcdock",
    "serverless",
    "function",
    "$FUNCTION_NAME"
  ],
  "author": "Your Name",
  "license": "MIT"
}
EOF

log $GREEN "‚úÖ Created package.json"

# Create route.config.json
cat > "$FUNCTION_DIR/route.config.json" << EOF
{
  "base": "/$FUNCTION_NAME",
  "handler": "handler.js",
  "routes": [
    {
      "path": "/",
      "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
    },
    {
      "path": "/status",
      "handler": "status.js",
      "methods": ["GET"]
    },
    {
      "path": "/health",
      "handler": "health.js",
      "methods": ["GET"]
    },
    {
      "path": "/items/:id",
      "handler": "items.js",
      "methods": ["GET", "PUT", "DELETE"]
    },
    {
      "path": "/users/:userId/posts/:postId",
      "handler": "users.js",
      "methods": ["GET"]
    }
  ]
}
EOF

log $GREEN "‚úÖ Created route.config.json"

# Create cron.json (optional)
cat > "$FUNCTION_DIR/cron.json" << EOF
{
  "jobs": [
    {
      "name": "example-job",
      "schedule": "0 */6 * * *",
      "handler": "cron-handler.js",
      "timezone": "UTC",
      "description": "Example cron job that runs every 6 hours"
    }
  ]
}
EOF

log $GREEN "‚úÖ Created cron.json (optional - remove if not needed)"

# Create cron-handler.js (optional)
cat > "$FUNCTION_DIR/cron-handler.js" << EOF
/**
 * Cron job handler for $FUNCTION_NAME function
 * This handler is called by scheduled cron jobs
 */

export default async (req, res) => {
  const { logger, cronJob, schedule, timestamp } = req;
  
  logger.info(\`Cron job started: \${cronJob}\`, {
    schedule,
    timestamp,
    functionName: req.functionName
  });

  try {
    // Implement your scheduled task logic here
    const result = {
      message: \`Cron job \${cronJob} executed successfully\`,
      function: '$FUNCTION_NAME',
      timestamp,
      schedule
    };
    
    logger.info(\`Cron job completed: \${cronJob}\`, result);
    
    res.json({
      success: true,
      job: cronJob,
      result
    });
    
  } catch (error) {
    logger.error(\`Cron job failed: \${cronJob}\`, { error: error.message });
    
    res.status(500).json({
      success: false,
      job: cronJob,
      error: error.message,
      timestamp
    });
  }
};
EOF

log $GREEN "‚úÖ Created cron-handler.js (optional - remove if not needed)"

# Create test file
cat > "$FUNCTION_DIR/handler.test.js" << EOF
/**
 * Test file for $FUNCTION_NAME handler
 * 
 * This demonstrates how to test FuncDock functions using Jest and Nock
 */

import { 
  testHandler, 
  expectStatus, 
  expectResponseFields,
  mockEnvVars,
  nock
} from '../../test/setup.js';

// Import the handler to test
import handler from './handler.js';

describe('$FUNCTION_NAME Handler', () => {
  // Mock environment variables for testing
  mockEnvVars({
    NODE_ENV: 'test',
    LOG_LEVEL: 'error'
  });

  describe('GET requests', () => {
    it('should return successful response for GET requests', async () => {
      const { res } = await testHandler(handler, {
        method: 'GET',
        query: { id: 'test-123' }
      });

      expectStatus(res, 200);
      expectResponseFields(res.body, {
        message: 'GET request successful',
        function: '$FUNCTION_NAME'
      });
      expect(res.body.data).toMatchObject({
        id: 'test-123',
        status: 'active',
        version: '1.0.0'
      });
    });

    it('should handle GET requests without ID parameter', async () => {
      const { res } = await testHandler(handler, {
        method: 'GET'
      });

      expectStatus(res, 200);
      expect(res.body.data.id).toBe('no-id-provided');
    });
  });

  describe('POST requests', () => {
    it('should create a resource successfully', async () => {
      const testData = { name: 'Test Item', value: 42 };
      
      const { res } = await testHandler(handler, {
        method: 'POST',
        body: testData
      });

      expectStatus(res, 201);
      expectResponseFields(res.body, {
        message: 'Resource created successfully',
        function: '$FUNCTION_NAME'
      });
      expect(res.body.data).toMatchObject(testData);
      expect(res.body.data).toHaveProperty('id');
      expect(res.body.data).toHaveProperty('createdAt');
    });

    it('should return 400 for empty POST body', async () => {
      const { res } = await testHandler(handler, {
        method: 'POST',
        body: {}
      });

      expectStatus(res, 400);
      expectResponseFields(res.body, {
        error: 'Bad Request',
        message: 'Request body is required'
      });
    });
  });

  describe('PUT requests', () => {
    it('should update a resource successfully', async () => {
      const updateData = { name: 'Updated Item', status: 'modified' };
      
      const { res } = await testHandler(handler, {
        method: 'PUT',
        query: { id: '123' },
        body: updateData
      });

      expectStatus(res, 200);
      expectResponseFields(res.body, {
        message: 'Resource 123 updated successfully',
        function: '$FUNCTION_NAME'
      });
      expect(res.body.data).toMatchObject({
        id: '123',
        ...updateData
      });
      expect(res.body.data).toHaveProperty('updatedAt');
    });

    it('should return 400 when no ID is provided', async () => {
      const { res } = await testHandler(handler, {
        method: 'PUT',
        body: { name: 'Test' }
      });

      expectStatus(res, 400);
      expectResponseFields(res.body, {
        error: 'Bad Request',
        message: 'ID parameter is required for updates'
      });
    });
  });

  describe('DELETE requests', () => {
    it('should delete a resource successfully', async () => {
      const { res } = await testHandler(handler, {
        method: 'DELETE',
        query: { id: '123' }
      });

      expectStatus(res, 200);
      expectResponseFields(res.body, {
        message: 'Resource 123 deleted successfully',
        function: '$FUNCTION_NAME'
      });
      expect(res.body.data).toMatchObject({
        id: '123'
      });
      expect(res.body.data).toHaveProperty('deletedAt');
    });

    it('should return 400 when no ID is provided for deletion', async () => {
      const { res } = await testHandler(handler, {
        method: 'DELETE'
      });

      expectStatus(res, 400);
      expectResponseFields(res.body, {
        error: 'Bad Request',
        message: 'ID parameter is required for deletion'
      });
    });
  });

  describe('OPTIONS requests', () => {
    it('should handle preflight requests', async () => {
      const { res } = await testHandler(handler, {
        method: 'OPTIONS'
      });

      expectStatus(res, 200);
      expect(res.headersSent).toBe(true);
    });
  });

  describe('Unsupported methods', () => {
    it('should return 405 for unsupported methods', async () => {
      const { res } = await testHandler(handler, {
        method: 'PATCH'
      });

      expectStatus(res, 405);
      expectResponseFields(res.body, {
        error: 'Method Not Allowed',
        method: 'PATCH'
      });
      expect(res.body.supportedMethods).toContain('GET');
      expect(res.body.supportedMethods).toContain('POST');
    });
  });

  describe('Logging', () => {
    it('should log request information', async () => {
      const { req } = await testHandler(handler, {
        method: 'GET',
        query: { id: 'test-123' }
      });

      const logs = req.logger.getLogs();
      expect(logs.info.length).toBeGreaterThan(0);
      
      // Check that request was logged
      const requestLog = logs.info.find(log => 
        log.message.includes('Request received')
      );
      expect(requestLog).toBeDefined();
    });
  });

  describe('HTTP mocking with Nock', () => {
    it('should handle external API calls', async () => {
      // Mock an external API call
      nock('https://api.example.com')
        .get('/data/123')
        .reply(200, {
          id: '123',
          name: 'Test Data',
          value: 42
        });

      // Create a handler that makes external API calls
      const apiHandler = async (req, res) => {
        const response = await fetch('https://api.example.com/data/123');
        const data = await response.json();
        
        res.json({
          message: 'External data retrieved',
          data,
          function: req.functionName
        });
      };

      const { res } = await testHandler(apiHandler, {
        method: 'GET'
      });

      expectStatus(res, 200);
      expectResponseFields(res.body, {
        message: 'External data retrieved',
        function: 'test-function'
      });
      expect(res.body.data).toMatchObject({
        id: '123',
        name: 'Test Data',
        value: 42
      });
    });
  });
});
EOF

log $GREEN "‚úÖ Created handler.test.js"

# Create README.md for the function
cat > "$FUNCTION_DIR/README.md" << EOF
# $FUNCTION_NAME Function

Generated by FuncDock template creator.

## Description

This is a serverless function template for the $FUNCTION_NAME service.

## Routes

- \`GET /$FUNCTION_NAME/\` - Get resource information
- \`POST /$FUNCTION_NAME/\` - Create a new resource
- \`PUT /$FUNCTION_NAME/?id=<id>\` - Update an existing resource
- \`DELETE /$FUNCTION_NAME/?id=<id>\` - Delete a resource
- \`GET /$FUNCTION_NAME/status\` - Get function status
- \`GET /$FUNCTION_NAME/health\` - Health check

## Cron Jobs

This function includes an example cron job configuration:

- \`cron.json\` - Defines scheduled jobs
- \`cron-handler.js\` - Handles cron job execution

The example job runs every 6 hours. Modify or remove these files if you don't need scheduled tasks.

## Example Usage

\`\`\`bash
# Get function status
curl http://localhost:3000/$FUNCTION_NAME/

# Create a resource
curl -X POST http://localhost:3000/$FUNCTION_NAME/ \\
  -H "Content-Type: application/json" \\
  -d '{"name": "example", "data": "test"}'

# Update a resource
curl -X PUT http://localhost:3000/$FUNCTION_NAME/?id=123 \\
  -H "Content-Type: application/json" \\
  -d '{"name": "updated", "data": "modified"}'

# Delete a resource
curl -X DELETE http://localhost:3000/$FUNCTION_NAME/?id=123
\`\`\`

## Development

1. Modify \`handler.js\` to implement your business logic
2. Add dependencies to \`package.json\` if needed
3. Update \`route.config.json\` if you need different routes
4. The function will auto-reload when you save changes

## Testing

This function includes comprehensive test coverage using Jest and Nock:

- \`handler.test.js\` - Unit tests for the main handler
- Tests cover all HTTP methods (GET, POST, PUT, DELETE, OPTIONS)
- Includes HTTP mocking for external API calls
- Tests error handling and edge cases
- Validates logging and response formats

### Running Tests

\`\`\`bash
# Run all tests
npm test

# Run tests for this function only
npm run test:functions

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage
\`\`\`

### Test Structure

- **Unit Tests**: Test individual handler functions in isolation
- **Integration Tests**: Test external API interactions using Nock
- **Error Handling**: Test various error scenarios
- **Logging**: Verify that requests are properly logged

## Environment Variables

Add any environment variables your function needs to the main \`.env\` file in the project root.
EOF

log $GREEN "‚úÖ Created README.md"

# Success message
echo ""
log $GREEN "üéâ Function template created successfully!"
echo ""
log $BLUE "Next steps:"
log $YELLOW "1. Edit functions/$FUNCTION_NAME/handler.js to implement your logic"
log $YELLOW "2. Add any dependencies to functions/$FUNCTION_NAME/package.json"
log $YELLOW "3. Modify functions/$FUNCTION_NAME/route.config.json if needed"
log $YELLOW "4. Start FuncDock: npm run dev"
log $YELLOW "5. Test your function: curl http://localhost:3000/$FUNCTION_NAME/"
echo ""
log $BLUE "Function will be available at: http://localhost:3000/$FUNCTION_NAME/"
